class Thorax.Views.MeasurePatientDashboard extends Thorax.Views.BonnieView

  template: JST['measure/patient_dashboard']

  initialize: ->
    @results = []
    @model.get('populations').each (population) =>
      @results.push(population.calculationResults().toJSON())

    #TODO Duplication of code for mapping code to race / ethnicity - See patient_builder.hbs
    @race_map = {}
    @race_map["1002-5"] = "American Indian or Alaska Native"
    @race_map['2028-9'] = "Asian"
    @race_map["2054-5"] = "Black or African American"
    @race_map["2076-8"]= "Native Hawaiian or Other Pacific Islander"
    @race_map["2106-3"] = "White"
    @race_map["2131-1"] = "Other"

    @ethnicity_map = {}
    @ethnicity_map["2186-5"] = "Not Hispanic or Latino"
    @ethnicity_map["2135-2"] = "Hispanic Or Latino"

    @COL_WIDTH_NAME = 140
    @COL_WIDTH_POPULATION = 36
    @COL_WIDTH_META = 150
    @COL_WIDTH_FREETEXT = 240
    @COL_WIDTH_CRITERIA = 180
      
    @getData()

    @FIXED_ROWS = 2
    @FIXED_COLS = @getFixedColumnCount(@dataIndices, @populations)

    @expandedRows = [] # used to ensure that expanded rows stay expanded after re-render
    @editableRows = [] # used to ensure rows marked for inline editing stay that way after re-render

    @editableCols = @getEditableCols() # these are the fields that should be inline editable

  events:
    rendered: ->
      $('.container').removeClass('container').addClass('container-fluid')
    destroyed: ->
      $('.container-fluid').removeClass('container-fluid').addClass('container')

    ready: ->
      @createTable()


  createTable: ->
    container = @$('#patient_dashboard_table').get(0)
    patients = @model.get('patients')
    hot = new Handsontable(container, {
      data: @createData(patients),
      colWidths: @getColWidths(),
      copyPaste: false, # need this to avoid 508 issue
      fixedRowsTop: @FIXED_ROWS,
      fixedColumnsLeft: @FIXED_COLS,
      mergeCells: @createMergedCells(@model, patients),
      readOnly: true,
      readOnlyCellClassName: '', # avoid using the default .htDimmed... it'll just make the whole table grey.
      renderAllRows: true, # handsontable's optimizer for rendering doesn't manage hidden rows well. Rendering all to fix.
      cells: (row, col, prop) =>
        cellProperties = {};
        if row == 0
          cellProperties.renderer = @header1Renderer
        else if row == 1
          cellProperties.renderer = @header2Renderer
        else
          cellProperties.renderer = @dataRenderer
        return cellProperties
      ,
      afterSelection: (rowIndexStart, colIndexStart, rowIndexEnd, colIndexEnd) =>
        if colIndexStart == colIndexEnd && rowIndexStart == rowIndexEnd
          if colIndexStart == 0
            @makeInlineEditable(container, hot, rowIndexStart)
          if colIndexStart == 1
            @toggleExpandableRow(container, rowIndexStart)
          if colIndexStart == 2
            # TODO: figure out what actually needs to be passed into this view to appropraitely pass into the patient edit view
            patientEditView = new Thorax.Views.MeasurePatientEditModal(model: @model.get('patients').models[0], measure: @model, patients: @model.get('patients'), measures = @model.collection)
            patientEditView.appendTo(@$el)
            patientEditView.display()
      ,
      afterRender: (isForced) =>
        # go through every table and adjust the markup generated by HOT
        for table in $('table.htCore')
          $(table).addClass('table')

          header_row1 = $(table).find('tr:not([data-row]):first-child td')
          header_row2 = $(table).find('tr:not([data-row]):nth-child(2) td')

          for cell in header_row1
            unless $(cell).attr('colspan') is undefined
              # replace <td> tags with <th> tags manually
              $(cell).replaceWith(
                '<th colspan='+$(cell).attr('colspan')+
                ' scope="col" class='+$(cell).attr('class')+
                '>'+$(cell).html()+'</th>')
            else if $(cell).attr('style') is "display: none;"
              # ensures table has same number of columns in every row
              $(cell).detach()

          for cell, index in header_row2
            # replace <td> tags with <th> tags manually
            classes = $(cell).attr('class')
            isExpectedValue = index >= @dataCollections['expected'].firstIndex && index <= @dataCollections['expected'].lastIndex
            isActualValue = index >= @dataCollections['actual'].firstIndex && index <= @dataCollections['actual'].lastIndex
            if (isExpectedValue || isActualValue)
              classes = classes + " rotate"

            $(cell).replaceWith('<th scope="col" class='+classes+'>'+$(cell).html()+'</th>')
      })

  makeInlineEditable: (container, hot, rowIndex) =>
    for table in $(container).find('table')
      tr = $(table).find('tr[data-row="row' + rowIndex.toString() + '"]').get(0)
      if tr
        if $(tr).hasClass('inline-edit-mode')
          Handsontable.Dom.removeClass(tr, 'inline-edit-mode')
          @editableRows = @editableRows.filter (index) -> index != rowIndex
        else
          Handsontable.Dom.addClass(tr, 'inline-edit-mode')
          @editableRows.push(rowIndex)

    for col in @editableCols
      if rowIndex in @editableRows
        hot.setCellMeta(rowIndex, col, 'readOnly', false)
      else
        hot.setCellMeta(rowIndex, col, 'readOnly', true)

  toggleExpandableRow: (container, rowIndex) =>
    if rowIndex > 1 && rowIndex%2 == 0
      expandableRowIndex = rowIndex + 1
      for table in $(container).find('table')
        tr = $(table).find('tr[data-row="row' + expandableRowIndex.toString() + '"]').get(0)
        if tr
          if $(tr).hasClass('expandable-hidden')
            Handsontable.Dom.removeClass(tr, 'expandable-hidden')
            Handsontable.Dom.addClass(tr, 'expandable-shown')
            @expandedRows.push(expandableRowIndex)
          else
            Handsontable.Dom.removeClass(tr, 'expandable-shown')
            Handsontable.Dom.addClass(tr, 'expandable-hidden')
            @expandedRows = @expandedRows.filter (index) -> index != expandableRowIndex

  header1Renderer: (instance, td, row, col, value, cellProperties) =>
    Handsontable.renderers.TextRenderer.apply(this, arguments)
    @addDiv(td)
    @getColor(instance, td, row, col, value, cellProperties)

  header2Renderer: (instance, td, row, col, value, cellProperties) =>
    Handsontable.renderers.TextRenderer.apply(this, arguments)
    isExpectedValue = col >= @dataCollections['expected'].firstIndex && col <= @dataCollections['expected'].lastIndex
    isActualValue = col >= @dataCollections['actual'].firstIndex && col <= @dataCollections['actual'].lastIndex
    if (isExpectedValue || isActualValue)
      @addDiv(td)
    else
      @addScroll(td)

  dataRenderer: (instance, td, row, col, value, cellProperties) =>
    Handsontable.renderers.TextRenderer.apply(this, arguments)
    Handsontable.Dom.addClass(td, 'content')
    @addDiv(td)
    # enabling expandable detail rows. Need to do by a custom data-attribute
    # because of how handsontable efficiently renders the table
    tr = td.parentElement
    $(tr).attr('data-row', "row" + row)
    if row%2 == 1
      if row in @expandedRows
        Handsontable.Dom.addClass(tr, 'expandable-shown')
      else
        Handsontable.Dom.addClass(tr, 'expandable-hidden')
    # enabling edit modes for the table
    if row in @editableRows
      Handsontable.Dom.addClass(tr, 'inline-edit-mode')
      if col in @editableCols
        instance.setCellMeta(row, col, 'readOnly', false)
    if col in @editableCols
      Handsontable.Dom.addClass(td, 'editable')

  getColor: (instance, td, row, col, value, cellProperties) =>
    for population in @populations
      if col >= @dataCollections[population].firstIndex && col <= @dataCollections[population].lastIndex
        Handsontable.Dom.addClass(td, population.toLowerCase())

  addDiv: (element) =>
    text = element.textContent
    element.firstChild.remove()
    if text == 'FALSE'
      $(element).append('<div class="text-danger"><i aria-hidden="true" class="fa fa-fw fa-times-circle"></i> ' + text + '</div>')
    else if text == 'TRUE'
      $(element).append('<div class="text-success"><i aria-hidden="true" class="fa fa-fw fa-check-circle"></i> ' + text + '</div>')
    else if text.indexOf('SPECIFIC') >= 0
      $(element).append('<div class="text-danger"><i aria-hidden="true" class="fa fa-fw fa-asterisk"></i> ' + text + '</div>')
    else
      $(element).append('<div>' + text + '</div>')

  addScroll: (element) =>
    text = element.textContent
    element.firstChild.remove()
    $(element).append('<div class="tableScrollContainer"><div class="tableScroll">' + text + '</div></div>')

  getColWidths: ()  =>
    colWidths = []
    
    for data in @dataIndices
      if data of @dataInfo
        colWidths.push(@dataInfo[data].width)

     colWidths

  createData: (patients) =>
    data = []
    headers = @createHeaderRows(patients)
    data.push(headers[0])
    data.push(headers[1])

    @createPatientRows(patients, data)

    return data

  createMergedCells: (measure, patients) =>
    mergedCells = []
    
    for key, dataCollection of @dataCollections
      if dataCollection.items.length > 0
        length = dataCollection.items.length
        mergedCells.push({row:0, col:dataCollection.firstIndex, colspan: length, rowspan: 1})

    return mergedCells

  getEditableCols:() =>
    editableFields = ["first", "last", "notes", "birthdate", "ethnicity", "race", "gender", "expired", "deathdate"]
    editableCols = []

    for editableField in editableFields
      editableCols.push(@dataIndices.indexOf(editableField))

    # make expected population results editable
    for population in @populations
      editableCols.push(@dataIndices.indexOf('expected' + population))

    return editableCols

  createHeaderRows: (patients) =>
    row1a = []
    row2a = []
    
    for data in @dataIndices
      row2a.push(@dataInfo[data].name)
    
    row1a.push('') for i in [1..row2a.length]
    
    for key, dataCollection of @dataCollections
      row1a[dataCollection.firstIndex] = dataCollection.name

    [row1a, row2a]

  createPatientRows: (patients, data) =>
    for patient, i in patients.models
      patientRow = @createPatientRow(patient);
      patientDetailRow = @createPatientDetailRow(patient, i, patientRow);
      data.push(patientRow);
      data.push(patientDetailRow);

  # TODO: modify all cases where the actual "key" needs to be used to use @getKeyValueFromDataIndices
  createPatientRow: (patient) =>
    patient_values = []
     
    patient_result = @match_patient_to_patient_id(patient.id)
    
    for dataType in @dataIndices
      if dataType == 'actions' 
        patient_values.push('
          <i aria-hidden="true" class="fa fa-fw fa-caret-right text-primary"><span class="sr-only">Expand row</span></i>

          <button class="btn btn-xs btn-primary">
            <i aria-hidden="true" class="fa fa-fw fa-pencil"></i>
            <span class="sr-only">Edit this patient inline</span>
          </button>

          <button class="btn btn-xs btn-default">Open...</button>
          ') # TODO: How to make these buttons trigger events??
      else if @isExpectedValueFromDataIndices(dataType)
        patient_values.push(@extract_patient_expected_value(patient, @getKeyValueFromDataIndices(dataType)))
      else if @isActualValueFromDataIndices(dataType)
        patient_values.push(@extract_value_for_population_type(patient_result, @getKeyValueFromDataIndices(dataType)))
      else if dataType == 'ethnicity'
        patient_values.push(@ethnicity_map[patient.get(dataType)])
      else if dataType == 'race'
        patient_values.push(@race_map[patient.get(dataType)])
      else if dataType == 'expired'
        value = if patient.get(dataType) != true then false else true
        patient_values.push(value)
      else if (dataType == 'birthdate' || dataType == 'deathdate') && patient.get(dataType) != null
        patient_values.push(moment.utc(patient.get(dataType)).format('L'))
      else if @isCriteriaKeyFromDataIndices(dataType)
        criteriaKey = @getKeyValueFromDataIndices(dataType)
        patient_values.push(@getPatientCriteriaResult(criteriaKey, patient_result))
      else
        patient_values.push(patient.get(dataType))
        
    patient_values

  match_patient_to_patient_id: (patient_id) =>
    patients = @results[0] #TODO will need to add population_set support
    # Iterate over each of the patients to match the patient_id
    patient = (patient for patient in patients when patient.patient_id == patient_id)[0]

  # TODO: rework the two functions below to reduce number of redundant calls (e.g. 'expected_model = ..' will get called each time this is called)
  extract_patient_expected_value: (patient, population) =>
    expected_model = (model for model in patient.get('expected_values').models when model.get('measure_id') == @model.get('hqmf_set_id'))[0]
    if population not in expected_model.keys()
      expected_value = 0
    else
      expected_value = expected_model.get(population)
    expected_value

  extract_value_for_population_type: (patient_result, population) =>
    # TODO: check this logic
    if population == 'OBSERV'
      if 'values' of patient_result && population of patient_result['rationale']
        patient_actual = patient_result['values'].toString()
      else
        patient_actual = (0)
    else if population of patient_result
      patient_actual = patient_result[population]
    else
      patient_actual = 'X'
    return patient_actual

  getPatientCriteriaResult: (criteriaKey, patientResult) =>
    # TODO: check this logic
    if criteriaKey of patientResult['rationale']
      value = patientResult['rationale'][criteriaKey]
      if value != null && value != 'false' && value != false
        result = 'TRUE'
      else if value == 'false' || value == false
        result = 'FALSE'
      
      # value = result
      # 
      # if 'specificsRationale' of patientResult && @populations[index] of patientResult['specificsRationale']
      #   specific_value = patientResult['specificsRationale'][@populations[index]][criteria]
      #   if specific_value == false  && value == 'TRUE'
      #     result = 'SPECIFICALLY FALSE'
      #   else if specific_value == true && value == 'FALSE'
      #     result = 'SPECIFICALLY TRUE'

    else
      result = ''

    result

  ######################
  ## TODO: this should go in its own model
  ######################

  getData: ->
    #Grab all populations related to this measure
    codes = (population['code'] for population in @model.get('measure_logic'))
    @populations = _.intersection(Thorax.Models.Measure.allPopulationCodes, codes)

    criteria_keys_by_population = {} # "Type" => "Preconditions"
    for code in Thorax.Models.Measure.allPopulationCodes #TODO add multiple population_set support
      if code in Object.keys(@model.get('populations')['models'][0]['attributes'])
        preconditions = @model.get('populations')['models'][0].get(code)['preconditions']
        if preconditions
          criteria_keys_by_population[code] = @precondition_criteria_keys(preconditions[0]).filter (ck) -> ck != 'MeasurePeriod'
        else
          criteria_keys_by_population[code] = []
    
    @dataIndices = @getDataIndices(@populations, criteria_keys_by_population)
    @dataCollections = @getDataCollections(@populations, @dataIndices, criteria_keys_by_population)
    @dataInfo = @getDataInfo(@populations, @dataCollections)

  getDataIndices: (populations, criteria_keys_by_population) =>
    dataIndices = []
    
    dataIndices.push("actions")
    dataIndices.push("first")
    dataIndices.push("last")
    
    for population in populations
      dataIndices.push("expected" + population)
    for population in populations
      dataIndices.push("actual" + population)
    
    dataIndices.push("notes")
    dataIndices.push("birthdate")
    dataIndices.push("expired")
    dataIndices.push("deathdate")
    dataIndices.push("race")
    dataIndices.push("ethnicity")
    dataIndices.push("gender")
    
    for population in populations
      criteria = criteria_keys_by_population[population]
      for criterium in criteria
        dataIndices.push(population + '_' + criterium)
    
    dataIndices
    
  getDataInfo: (populations, dataCollections) =>
    dataInfo = {}
    
    dataInfo.actions = { name: "Actions", width: @COL_WIDTH_META }
    dataInfo.first = { name: "First Name", width: @COL_WIDTH_NAME }
    dataInfo.last = { name: "Last Name", width: @COL_WIDTH_NAME }
    dataInfo.notes = { name: "Notes", width: @COL_WIDTH_FREETEXT }
    dataInfo.birthdate = { name: "Birthdate", width: @COL_WIDTH_META }
    dataInfo.expired = { name: "Expired?", width: @COL_WIDTH_META }
    dataInfo.deathdate = { name: "Deathdate", width: @COL_WIDTH_META }
    dataInfo.race = { name: "Race", width: @COL_WIDTH_META }
    dataInfo.ethnicity = { name: "Ethnicity", width: @COL_WIDTH_META }
    dataInfo.gender = { name: "Gender", width: @COL_WIDTH_META }
    
    # Grab all data criteria and pass them into DataCriteriaLogic
    dataCriteriaText = {}
    for reference in Object.keys(@model.get('data_criteria'))
      dataLogicView = new Thorax.Views.DataCriteriaLogic(reference: reference, measure: @model)
      dataLogicView.appendTo(@$el)
      dataCriteriaText[dataLogicView.dataCriteria.key] = dataLogicView.$el[0].outerText
    
    for population in populations
      dataInfo["expected" + population] = { name: population, width: @COL_WIDTH_POPULATION }
      dataInfo["actual" + population] = { name: population, width: @COL_WIDTH_POPULATION }
      
      dataCollection = dataCollections[population]
      for item in dataCollection.items
        dataInfo[population + '_' + item] = { name: dataCriteriaText[item], width: @COL_WIDTH_CRITERIA }

    return dataInfo
    
  getDataCollections: (populations, dataIndices, criteria_keys_by_population) =>
    # indices get added when defining the @dataIndices
    dataCollections = {}
    dataCollections.actions = {name: "", items: ["actions"] }
    dataCollections.name = { name: "Names", items: ["first", "last"] }
    dataCollections.expected = { name: "Expected", items: "expected" + pop for pop in populations }
    dataCollections.actual = { name: "Actual", items: "actual" + pop for pop in populations }
    dataCollections.metadata = {name: "Metadata", items: ["notes", "birthdate", "expired", "deathdate", "race", "ethnicity", "gender"]}
    
    for population in populations
      dataCollections[population] = { name: population, items: criteria for criteria in criteria_keys_by_population[population] }
    
    for key, dataCollection of dataCollections
      dataCollection.firstIndex = @_getFirstIndex(dataCollection.items, key)
      dataCollection.lastIndex = dataCollection.firstIndex + dataCollection.items.length - 1
    
    return dataCollections

  _getFirstIndex: (items, collectionKey) ->
    for item in items
      if collectionKey in @populations
        item = collectionKey + '_' + item
      itemIndex = @dataIndices.indexOf(item)
      index = itemIndex if !index || index > itemIndex
      
    index
    
  # TODO: this doesn't seem like the right way to get this... needs to be more abstracted out or fed in from somewhere else
  getFixedColumnCount: () =>
    lastPop = @populations[@populations.length - 1]
    @dataIndices.indexOf("expected" + lastPop) + 1
        
  getDataIndicesCriteriaStartIndex: () =>
    for pop in @populations
      if @dataCollections[pop].items.length > 0
        index = @dataCollections[pop].firstIndex
        break
    index
  
  isExpectedValueFromDataIndices: (dataKey) =>
    dataKey.startsWith('expected')
    
  isActualValueFromDataIndices: (dataKey) =>
    dataKey.startsWith('actual')
    
  isCriteriaKeyFromDataIndices: (dataKey) =>
    dataIndex = @dataIndices.indexOf(dataKey)
    criteriaStartIndex = @getDataIndicesCriteriaStartIndex()
    dataIndex >= criteriaStartIndex
  
  getKeyValueFromDataIndices: (dataKey) =>
    if @isExpectedValueFromDataIndices(dataKey)
      keyValue = dataKey.substring('expected'.length)
    else if @isActualValueFromDataIndices(dataKey)
      keyValue = dataKey.substring('actual'.length)
    else if @isCriteriaKeyFromDataIndices(dataKey)
      startIndex = dataKey.indexOf('_') + 1
      keyValue = dataKey.substring(startIndex)
    else
      keyValue = dataKey

    return keyValue

  # Given a data criteria, return the list of all data criteria keys referenced within, either through
  # children criteria or temporal references; this includes the passed in criteria reference
  data_criteria_criteria_keys: (criteria_reference) =>
    criteria_keys = [criteria_reference]
    if criteria = @model.get('data_criteria')[criteria_reference]
      if criteria['children_criteria']?
        criteria_keys = criteria_keys.concat(@data_criteria_criteria_keys(criteria) for criteria in criteria['children_criteria'])
        criteria_keys = flatten(criteria_keys)
      if criteria['temporal_references']?
        criteria_keys = criteria_keys.concat(@data_criteria_criteria_keys(temporal_reference['reference']) for temporal_reference in criteria['temporal_references'])
        criteria_keys = flatten(criteria_keys)

    return criteria_keys

  # Given a precondition, return the list of all data criteria keys referenced within
  precondition_criteria_keys: (precondition) =>
    if precondition['preconditions'] && precondition['preconditions'].length > 0
      results = (@precondition_criteria_keys(precondition) for precondition in precondition['preconditions'])
      results = flatten(results)
    else if precondition['reference']
      @data_criteria_criteria_keys(precondition['reference'])
    else
      []

#TODO Make this coffeescript. Or use underscore.js
  `function flatten(arr) {
    const flat = [].concat(...arr)
    return flat.some(Array.isArray) ? flatten(flat) : flat;
  }`

###################################################################################

  createPatientDetailRow: (patient, rowIndex, patientSummaryRow) =>
    row = [];
    for value in patientSummaryRow
      row.push("DETAIL " + rowIndex.toString())
    return row

class Thorax.Views.MeasurePatientEditModal extends Thorax.Views.BonnieView
  template: JST['measure/patient_edit_modal']

  events:
    'ready': 'setup'

  initialize: ->
    @patientBuilderView = new Thorax.Views.PatientBuilder(model: @model, measure: @measure, patients: @patients, measures: @measures, showCompleteView: false)

  setup: ->
    @editDialog = @$("#patientEditModal")

  display: ->
    @editDialog.modal(
      "backdrop" : "static",
      "keyboard" : true,
      "show" : true).find('.modal-dialog').css('width','900px') # The same width defined in $modal-lg

  save: (e)->
    status = @patientBuilderView.save(e)
    if status
      @editDialog.modal(
        "backdrop" : "static",
        "keyboard" : false,
        "show" : true)
      @editDialog.modal('hide')

  close: -> ''
